apiVersion: v1
kind: ConfigMap
metadata:
  name: app
  labels:
    app: app
data:
  app.yml: |+
    server.port: 8080
    
    server.forward-headers-strategy: framework #
    
    jwt:
      HEADER_STRING: Authorization
      tokenPrefix: Bearer
      secretKey: JunChen522
      issuer: auth-server
    
    spring:
      main:
        allow-bean-definition-overriding: true
      application:
        name: app
      datasource:
        url: jdbc:postgresql://localhost/springecommerece
        username: postgres
        password: password
        driverClassName: org.postgresql.Driver
        #initialization-mode: always
      redis:
        host: localhost
        port: 6379
    
    # outputs
    # CMS and SMS does not need message queue, they only have read operations.
    spring.cloud.stream:
      bindings:             # only OMS,PMS,UMS have write operations. Read operations don't need to message queue, non-blocking synchronous.
        order-out-0:  # OMS
          destination: order
          producer:
            required-groups: auditGroup
        orderComplete-out-0: # OMS
          destination: orderComplete
          producer:
            required-groups: auditGroup
        cart-out-0:
          destination: cart
          producer:
            required-groups: auditGroup
        return-out-0:
          destination: return
          producer:
            required-groups: auditGroup
        review-out-0: # PMS
          destination: review
          producer:
            required-groups: auditGroup
        user-out-0:    # UMS
          destination: user
          producer:
            required-groups: auditGroup
    
    management.health.circuitbreakers.enabled: true
    
    resilience4j:
      timelimiter:
        instances:
          genericTimeLimiter:
            timeoutDuration: 2s
    
      retry:
        instances:
          genericRetry:
            maxAttempts: 3
            waitDuration: 1000
            retryExceptions:
              - org.springframework.web.reactive.function.client.WebClientResponseException$InternalServerError
    
      circuitbreaker:
        instances:
          genericCircuitBreaker:
            allowHealthIndicatorToFail: false
            registerHealthIndicator: true
            slidingWindowType: COUNT_BASED
            slidingWindowSize: 5
            failureRateThreshold: 50
            waitDurationInOpenState: 10000
            permittedNumberOfCallsInHalfOpenState: 3
            automaticTransitionFromOpenToHalfOpenEnabled: true
            ignoreExceptions:
              - com.itsthatjun.ecommerce.exception.InvalidInputException
              - com.itsthatjun.ecommerce.exception.NotFoundException
    
      rateLimiter:
        instances:
          genericRateLimiter:
            limitForPeriod: 5
            limitRefreshPeriod: 10000
            timeoutDuration: 1000
            enableExpiry: false
    
    ---
    
    spring.config.activate.on-profile: docker
    
    server.port: 80
    
    spring:
      datasource:
        url: jdbc:postgresql://postgres/springecommerece
      redis:
        host: redis
    
    ---
    
    spring.config.activate.on-profile: kafka
    
    spring.cloud.stream.bindings.order-out-0:
      partition-key-expression: headers['partitionKey']
    
    spring.cloud.stream.bindings.orderComplete-out-0:
      partition-key-expression: headers['partitionKey']
    
    spring.cloud.stream.bindings.cart-out-0:
      partition-key-expression: headers['partitionKey']
    
    spring.cloud.stream.bindings.return-out-0:
      partition-key-expression: headers['partitionKey']
    
    spring.cloud.stream.bindings.review-out-0:
      partition-key-expression: headers['partitionKey']
    
    spring.cloud.stream.bindings.user-out-0:
      partition-key-expression: headers['partitionKey']

  application.yml: |
    # message queue related and distributed tracing/Zipkin/Sleuth needed to collect logs
    spring:
      rabbitmq:
        host: localhost
        port: 5672
        virtual-host: /
        username: guest
        password: guest
        publisher-confirms: true
    
    spring.cloud.stream.defaultBinder: rabbit
    spring.zipkin.sender.type: rabbit
    spring.sleuth.sampler.probability: 1.0
    
    # WARNING: Exposing all management endpoints over http should only be used during development, must be locked down in production!
    management.endpoint.health.show-details: "ALWAYS"
    management.endpoints.web.exposure.include: "*"
    
    #    TRACE: The lowest level of logging that provides the most detailed information about what is happening in the application.
    #    DEBUG: A level higher than TRACE that provides information about application flow and internal state.
    #    INFO: A level higher than DEBUG that provides information about what the application is doing and its status.
    #    WARN: A level higher than INFO that indicates potentially harmful situations.
    #    ERROR: The highest level of logging that indicates errors that may cause the application to malfunction or fail.
    
    logging:
      level:
        #root: ERROR
        root: INFO
        org.springframework.security: DEBUG
        org.springframework.web.server.adapter.HttpWebHandlerAdapter: TRACE
        com.itsthatjun.ecommerce: DEBUG
    
    server.shutdown: graceful
    spring.lifecycle.timeout-per-shutdown-phase: 10s
    
    ---
    spring.config.activate.on-profile: docker
    
    spring.rabbitmq.host: rabbitmq
    
    # Disabled for kubernetes, use eureka profile to deploy on docker
    eureka.client.enabled: false
    
    ---
    spring.config.activate.on-profile: kafka
    
    spring.cloud.stream.defaultBinder: kafka
    spring.zipkin.sender.type: kafka
    
    spring.cloud.stream.kafka.binder:
      brokers: kafka
      defaultBrokerPort: 9092
    
    management.health.rabbit.enabled: false
    spring.kafka.bootstrap-servers: kafka:9092
    spring.cloud.stream.kafka.binder.replication-factor: 1
    
    ---
    spring.config.activate.on-profile: eureka
    
    app.eureka-server: eureka
    
    eureka:
      client:
        enabled: true
        serviceUrl:
          defaultZone: http://${app.eureka-server}:8761/eureka/
        initialInstanceInfoReplicationIntervalSeconds: 5
        registryFetchIntervalSeconds: 5
      instance:
        leaseRenewalIntervalInSeconds: 5
        leaseExpirationDurationInSeconds: 5